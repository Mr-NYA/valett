#include <Arduino.h>
#include <BLEPeripheral.h>

// Type de robot
String id="123456789";            // renvoyer l'adresse MAC
String Name ="Valett";
char Device_name[255]="Valett-dev";
char Local_name[255]="Valett";

//custom boards may override default pin definitions with BLEPeripheral(PIN_REQ, PIN_RDY, PIN_RST)
BLEPeripheral blePeripheral = BLEPeripheral();

// create service
BLEService valettService = BLEService("4010");

// create switch characteristic
BLECharacteristic moteurCharacteristic = BLECharacteristic("4011", BLEWrite, 255);
BLECharacteristic nameCharacteristic = BLECharacteristic("4012", BLEWrite, 255);


// Buffer de lecture des commandes reçues
char buffer[256];

// Moteur de basculement avant/arrière
int Pin1 = 0; 
int Pin2 = 1; 
int Pin3 = 2; 
int Pin4 = 3; 
// Moteur latéral gauche/droite
int Pin5 = 6; 
int Pin6 = 7; 
int Pin7 = 8; 
int Pin8 = 9; 

// Détetcion de fin de course gauche et droite
boolean Detect = false;
// Capteurs de fin de course gauche et droite
int PinStopG = 9;
int PinStopD = 10;
// Valeur des capteurs en fin de course
int SignalCapteur = 1;

// Etapes de chaque moteur
int step1 = 0;
int step2 = 0;
int stopmoteur1 = 8;
int stopmoteur2 = 8;
// Vitesse de déplacement de chaque moteur
int move1=0;
int move2=0;

// Délai en ms entre chaque étape de déplacement qui sera divisé par la vitesse
int delai=20; 
// Ratio de vitesse entre le moteur et le moteur 2
int ratio=2;

// Nombre d'étapes pour chaque commande
int nbstep=8;

// Pour gérer le timeout, 0 pas de timeout
unsigned long the_time;
unsigned long the_timeout=20000;

// Buffers
char readbuf[256] ;
char printbuf[256] ;

// Commandes de déplacement d'un moteur pas à pas
// Respecter un délai de 2 ms entre chaque étape
void stepper(int step, int P1, int P2, int P3, int P4){
    
         switch(step){
            case 0:
              digitalWrite(P1, LOW);
              digitalWrite(P2, LOW);
              digitalWrite(P3, LOW);
              digitalWrite(P4, HIGH);
            break; 
            case 1:
              digitalWrite(P1, LOW); 
              digitalWrite(P2, LOW);
              digitalWrite(P3, HIGH);
              digitalWrite(P4, HIGH);
            break; 
            case 2:
              digitalWrite(P1, LOW); 
              digitalWrite(P2, LOW);
              digitalWrite(P3, HIGH);
              digitalWrite(P4, LOW);
            break; 
            case 3:
              digitalWrite(P1, LOW); 
              digitalWrite(P2, HIGH);
              digitalWrite(P3, HIGH);
              digitalWrite(P4, LOW);
            break; 
            case 4:
              digitalWrite(P1, LOW); 
              digitalWrite(P2, HIGH);
              digitalWrite(P3, LOW);
              digitalWrite(P4, LOW);
            break; 
            case 5:
              digitalWrite(P1, HIGH); 
              digitalWrite(P2, HIGH);
              digitalWrite(P3, LOW);
              digitalWrite(P4, LOW);
            break; 
            case 6:
              digitalWrite(P1, HIGH); 
              digitalWrite(P2, LOW);
              digitalWrite(P3, LOW);
              digitalWrite(P4, LOW);
            break; 
            case 7:
              digitalWrite(P1, HIGH); 
              digitalWrite(P2, LOW);
              digitalWrite(P3, LOW);
              digitalWrite(P4, HIGH);
            break;
            case 8:
              digitalWrite(P1, LOW); 
              digitalWrite(P2, LOW);
              digitalWrite(P3, LOW);
              digitalWrite(P4, LOW);
            break; 
            default:
              digitalWrite(P1, LOW); 
              digitalWrite(P2, LOW);
              digitalWrite(P3, LOW);
              digitalWrite(P4, LOW);
            break; 
        }
}


// on a définit une méthode de traitement de la commande, commune pour la communication Serial et Bluetooth
void cmdTreatment(char * array){

  int len=strlen(array);
  int i;
  move1=move2=0;
  // première valeur : Vitesse basculement avant/arrière
    move1=atoi(array);
    if (move1 < -10) move1=-10;
    else if (move1 > 10) move1=10;
    // seconde valeur : Vitesse latérale gauche/droite
    for (i=0;i < len && array[i] != ' ';i++);
    if (i < len) {
      move2=atoi(array+i);
      if (move2 < -10) move2=-10;
      else if (move2 > 10) move2=10;
    }
    sprintf(printbuf,"Move %d %d",move1,move2);   
    Serial.println(printbuf);
    if (move1==0) stepper(stopmoteur1,Pin1,Pin2,Pin3,Pin4);
    if (move2==0) stepper(stopmoteur2,Pin5,Pin6,Pin7,Pin8);
    if (move1 || move2) the_time=millis();
}


void setup() {
//initialisation de serial Port
//Serial.begin(115200);
  Serial.begin(9600);
  // set advertised local name and service UUID
  blePeripheral.setLocalName(Local_name); 
  blePeripheral.setDeviceName(Device_name);
  blePeripheral.setAppearance(true);
  blePeripheral.setAdvertisedServiceUuid(valettService.uuid());

  // add service and characteristic
  blePeripheral.addAttribute(valettService);
  blePeripheral.addAttribute(moteurCharacteristic);
  //blePeripheral.addAttribute(nameCharacteristic);

  // begin initialization
  blePeripheral.begin();

  Serial.println(F("BLE Valett Peripheral"));

    // Moteur de basculement avant/arrière
    pinMode(Pin1, OUTPUT); 
    pinMode(Pin2, OUTPUT); 
    pinMode(Pin3, OUTPUT); 
    pinMode(Pin4, OUTPUT); 
    // Moteur latéral gauche/droite
    pinMode(Pin5, OUTPUT); 
    pinMode(Pin6, OUTPUT); 
    pinMode(Pin7, OUTPUT); 
    pinMode(Pin8, OUTPUT); 
    // Capteurs de fin de course gauche et droite
    if (Detect) {
        pinMode(PinStopG, INPUT); 
        pinMode(PinStopD, INPUT); 
    }
  delay(500);
}

void loop() {
  BLECentral central = blePeripheral.central();
  if (central) {   
    while (central.connected()) {
    // Données bluetooth disponibles 
      if (nameCharacteristic.written()) {  
        // A compléter
        // Pour caractéristique en read
        //switchCharacteristic.setValue((unsigned char *)SsidLocal,16) ;
      } 
      else if (moteurCharacteristic.written()) {   
        // lire les données envoyées par bluetooth de l'appareil
        strncpy(readbuf,(char*)moteurCharacteristic.value(),moteurCharacteristic.valueLength());
        readbuf[moteurCharacteristic.valueLength()]=0;
        sprintf(printbuf,"Moteur <%s> %d",readbuf,moteurCharacteristic.valueLength());   
        Serial.println(printbuf);
 
        //delay(250);    
        //faire appel à la méthode de traitement de la commande
        cmdTreatment(readbuf);   
      }

      if (move1 != 0 || move2 != 0) { // Dernière commande de déplacement
            // timeout
            if (the_timeout !=0 && (millis() - the_time >= the_timeout)) {
                Serial.println("Time out");
                move1=move2=0;
                stepper(stopmoteur1,Pin1,Pin2,Pin3,Pin4);
                stepper(stopmoteur2,Pin5,Pin6,Pin7,Pin8);
            }
            // test fin de course à droite ou à gauche
            if (Detect && move2 != 0) {
                int val;
                if (move2 < 0) val=digitalRead(PinStopG);
                else val=digitalRead(PinStopD);
                if (val == SignalCapteur) {
                    move2 = 0;  // pas de déplacement à droite
                }
            }

            if (move1 != 0 || move2 != 0) {
                int rat=ratio;
                Serial.print(".");
                for (int x=0;x<nbstep;x++) {
                    if (move1 != 0) {
                        stepper(step1,Pin1,Pin2,Pin3,Pin4);
                        if (move1 < 0) step1++; else step1 --;
                        if(step1>7) step1=0;
                        if(step1<0) step1=7;
                    }
                    if (move2 != 0 and rat==1) {                
                        stepper(step2,Pin5,Pin6,Pin7,Pin8);
                        if (move2 >0) step2++; else step2 --;
                        if(step2>7) step2=0;
                        if(step2<0) step2=7;
                    }
                    if (rat==1) rat=ratio; else rat--;
                    if (move1 != 0 and move2 == 0)
                        delay(delai/abs(move1));
                    else if (move2 != 0 and move1 == 0)
                        delay(delai/abs(move2));
                    else
                        // A améliorer pour vitesses indépendantes
                        delay(delai/max(abs(move1),abs(move2)));
                }
            }
      }
    }
  // central disconnected
  Serial.print(F("Disconnected from central: "));
  Serial.println(central.address());  
  }  
}


